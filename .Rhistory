source(file.path(dirThs,"../r_SelectModelByConcurvityFunctions.R"));
source(file.path(dirThs,"../r_PlotStats_BestModels.R"));
source(file.path(dirThs,"../r_PlotStats_BestModels.R"));
mdl = mdlB_ZE2D;
if (!exists("dfrCrsVal")) dfrCrsVal = wtsUtilities::getObj(file.path(dirThs,"rda_BinomialModels_CrsVal.RData"));
#--extract base model results
dfrCrsVal1 = dfrCrsVal |>
dplyr::filter(i==1) |> #--extract base model results
dplyr::select(fold,
base_rsqr=rsqr,base_aic=aic,base_rsqr_prd=rsqr_prd,
base_mspe_prd=mspe_prd,base_mase_prd=mase_prd);
#--calculate stats differences by fold relative to the base model stats
dfrCrsVald = dfrCrsVal |>
dplyr::left_join(dfrCrsVal1,by=c("fold")) |>
dplyr::mutate(impr_rsqr=rsqr-base_rsqr,
impr_aic=base_aic-aic,
impr_rsqr_prd=rsqr_prd-base_rsqr_prd,
impr_mspe_prd=(base_mspe_prd-mspe_prd)/base_mspe_prd,
impr_mase_prd=(base_mase_prd-mase_prd)/base_mase_prd);
#--summarize stats differences (mean, median) over folds
dfrCrsValdp = dfrCrsVald |>
dplyr::group_by(i,frmla,smths) |>
dplyr::summarize(scrSignifp=sum(as.numeric(signifp)),
scrSignifs=sum(as.numeric(signifs)),
scrConcrv_tst=sum(as.numeric(concrv_tst)),
mn_impr_rsqr=mean(impr_rsqr),
mn_impr_aic=mean(impr_aic),
mn_impr_rsqr_prd=mean(impr_rsqr_prd),
mn_impr_mspe_prd=mean(impr_mspe_prd),
mn_impr_mase_prd=mean(impr_mase_prd),
md_impr_rsqr=median(impr_rsqr),
md_impr_aic=median(impr_aic),
md_impr_rsqr_prd=median(impr_rsqr_prd),
md_impr_mspe_prd=median(impr_mspe_prd),
md_impr_mase_prd=median(impr_mase_prd)
) |>
dplyr::ungroup() |>
dplyr::arrange(i);
#--find best model based on concurvity, significant smooths, and mn_impr_mspe_prd
#----by arranging all models
dfrCrsValdp1 = dfrCrsValdp |>
dplyr::arrange(desc(scrConcrv_tst),
desc(scrSignifs),
desc(mn_impr_mspe_prd));
#--plot stats from models with better summary stats than the base model
plotStats_BestModels(dfrCrsVald,dfrCrsValdp1);
View(dfrCrsValdp1)
best_idx = dfrCrsValdp1$i[1];#--index of best model in evaluated combinations
best_mdl = evalBestModel(mdl,ks,best_idx);
getModelPlots(best_mdl);
best_mdl
summary(best_mdl)
simResids <- DHARMa::simulateResiduals(fittedModel = best_mdl, plot = F, n=1000);
DHARMa::plotQQunif(simResids);
DHARMa::plotResiduals(simResids);
best_idx = dfrCrsValdp1$i[2];#--index of best model in evaluated combinations
best_mdl = evalBestModel(mdl,ks,best_idx);
getModelPlots(best_mdl);
simResids <- DHARMa::simulateResiduals(fittedModel = best_mdl, plot = F, n=1000);
DHARMa::plotQQunif(simResids);
DHARMa::plotResiduals(simResids);
best_idx = dfrCrsValdp1$i[3];#--index of best model in evaluated combinations
best_mdl = evalBestModel(mdl,ks,best_idx);
getModelPlots(best_mdl);
best_idx = dfrCrsValdp1$i[2];#--index of best model in evaluated combinations
best_mdl = evalBestModel(mdl,ks,best_idx);
#--diagnostic plots
simResids <- DHARMa::simulateResiduals(fittedModel = best_mdl, plot = F, n=1000);
DHARMa::plotQQunif(simResids);
DHARMa::plotResiduals(simResids);
plts = getModelPlots(best_mdl);
wtsUtilities::saveObj(dfrCrsValdp1,file.path(dirThs,"rda_Step3b.BinomialModels_OrderedModels.RData"));
wtsUtilities::saveObj(best_mdl,    file.path(dirThs,"rda_BinomialModels_BestModel.RData"));
#--fit various models for ln(r) using mgcv to fit GAMs for males using the TWEEDIE distribution----
require(DHARMa);
require(dplyr);
require(ggplot2);
require(gratia)
require(mgcv);
#--get censored data and prediction grids----
dirThs = dirname(rstudioapi::getActiveDocumentContext()$path);
lst = wtsUtilities::getObj(file.path(dirThs,"rda_Step3a.CensoredDataAndGridsList.Males.RData"));
#--remove zeros, infs, questionable observed Rs----
dfrDatp   = dfrDat |> dplyr::filter(obsR<10, is.finite(lnR),between(z,15,150));
#--remove zeros, infs, questionable observed Rs----
dfrDatp   = lst$dfrDat |> dplyr::filter(obsR<10, is.finite(lnR),between(z,15,150));
#--TWEEDIE regression models for lnR---------------------
famTW = mgcv::tw(link="log");
#--------ALL Z 2-WAY INTERACTIONS--------------------------
#--ln(r) = ti(z) +
#          ti(d) + ti(t) + ti(f) + ti(s) +
#--        ti(z,d) + ti(z,t) + ti(z,f) +ti(z,s)
ks=c(10,8);
k1 = ks[1]; k2 = ks[2];
frmla  = obsR~ti(z,bs="ts",k=k1)   +
ti(d,bs="ts",k=k2)   + ti(t,bs="ts",k=k2)   + ti(f,bs="ts",k=k2)   + ti(s,bs="ts",k=k2) +
ti(z,d,bs="ts",k=c(k1,k2)) + ti(z,t,bs="ts",k=c(k1,k2)) + ti(z,f,bs="ts",k=c(k1,k2)) + ti(z,s,bs="ts",k=c(k1,k2));
mdlTW_ZE2D = mgcv::gam(frmla,family=famTW,data=dfrDatp,select=TRUE,method="REML",fit=FALSE);
source(file.path(dirThs,"../r_gam.prefit.functions.R"));
source(file.path(dirThs,"../r_SelectModelByConcurvityFunctions.R"));
set.seed(1111111);
mdl = mdlTW_ZE2D;
dfrCrsVal = runCrossValidation(
mdl,
ks,
dfrData=dfrDatp,
numFolds=10,
concrv_opt=2,
doParallel=TRUE,
ncores=parallel::detectCores()-1,
max_ncmbs=NULL,
icmbs=NULL,
log=TRUE,
debug=FALSE);
wtsUtilities::saveObj(dfrCrsVal,file.path(dirThs,"rda_TweedieModels_CrsVal.RData"));
source(file.path(dirThs,"../r_gam.prefit.functions.R"));
source(file.path(dirThs,"../r_SelectModelByConcurvityFunctions.R"));
source(file.path(dirThs,"../r_PlotStats_BestModels.R"));
mdl = mdlTW_ZE2D;
if (!exists("dfrCrsVal")) dfrCrsVal = wtsUtilities::getObj(file.path(dirThs,"rda_Step3b.TweedieModels_CrsVal.RData"));
#--extract base model results
dfrCrsVal1 = dfrCrsVal |>
dplyr::filter(i==1) |> #--extract base model results
dplyr::select(fold,
base_rsqr=rsqr,base_aic=aic,base_rsqr_prd=rsqr_prd,
base_mspe_prd=mspe_prd,base_mase_prd=mase_prd);
#--calculate stats differences by fold relative to the base model stats
dfrCrsVald = dfrCrsVal |>
dplyr::left_join(dfrCrsVal1,by=c("fold")) |>
dplyr::mutate(impr_rsqr=rsqr-base_rsqr,
impr_aic=base_aic-aic,
impr_rsqr_prd=rsqr_prd-base_rsqr_prd,
impr_mspe_prd=(base_mspe_prd-mspe_prd)/base_mspe_prd,
impr_mase_prd=(base_mase_prd-mase_prd)/base_mase_prd);
#--summarize stats differences (mean, median) over folds
dfrCrsValdp = dfrCrsVald |>
dplyr::group_by(i,frmla,smths) |>
dplyr::summarize(scrSignifp=sum(as.numeric(signifp)),
scrSignifs=sum(as.numeric(signifs)),
scrConcrv_tst=sum(as.numeric(concrv_tst)),
mn_impr_rsqr=mean(impr_rsqr),
mn_impr_aic=mean(impr_aic),
mn_impr_rsqr_prd=mean(impr_rsqr_prd),
mn_impr_mspe_prd=mean(impr_mspe_prd),
mn_impr_mase_prd=mean(impr_mase_prd),
md_impr_rsqr=median(impr_rsqr),
md_impr_aic=median(impr_aic),
md_impr_rsqr_prd=median(impr_rsqr_prd),
md_impr_mspe_prd=median(impr_mspe_prd),
md_impr_mase_prd=median(impr_mase_prd)
) |>
dplyr::ungroup() |>
dplyr::arrange(i);
#--find best model based on concurvity, significant smooths, and mn_impr_mspe_prd
#----by arranging all models
dfrCrsValdp1 = dfrCrsValdp |>
dplyr::arrange(desc(scrConcrv_tst),
desc(scrSignifs),
desc(mn_impr_mspe_prd));
#--plot stats from models with better summary stats than the base model
plotStats_BestModels(dfrCrsVald,dfrCrsValdp1);
View(dfrCrsValdp1)
best_idx = dfrCrsValdp1$i[1];#--index of best model in evaluated combinations
best_mdl = evalBestModel(mdl,ks,best_idx);
#--diagnostic plots
simResids <- DHARMa::simulateResiduals(fittedModel = best_mdl, plot = F, n=1000);
DHARMa::plotQQunif(simResids);
DHARMa::plotResiduals(simResids);
getModelPlots(best_mdl);
wtsUtilities::saveObj(dfrCrsValdp1,file.path(dirThs,"rda_Step3b.TweedieModels_OrderedModels.RData"));
wtsUtilities::saveObj(best_mdl,    file.path(dirThs,"rda_Step3b.TweedieModels_BestModel.RData"));
summary(best_mdl)
#--fit various models for ln(r) using mgcv to fit GAMs for males using the TWEEDIE distribution----
require(DHARMa);
require(dplyr);
require(ggplot2);
require(gratia)
require(mgcv);
#--get censored data and prediction grids----
dirThs = dirname(rstudioapi::getActiveDocumentContext()$path);
lst = wtsUtilities::getObj(file.path(dirThs,"rda_Step3a.CensoredDataAndGridsList.Males.RData"));
#--remove zeros, infs, questionable observed Rs----
dfrDatp   = lst$dfrDat |> dplyr::filter(obsR<10, is.finite(lnR),between(z,15,150));
#--TWEEDIE regression models for lnR---------------------
famTW = mgcv::tw(link="log");
#--------ALL Z 2-WAY INTERACTIONS--------------------------
#--ln(r) = ti(z) +
#          ti(d) + ti(t) + ti(f) + ti(s) +
#--        ti(z,d) + ti(z,t) + ti(z,f) +ti(z,s)
ks=c(10,8);
k1 = ks[1]; k2 = ks[2];
names(dfrDatp)
str(dfrDatp)
lvls = c("any",unique(dfrDatp$h));
dfrDatpp = dfrDatp |> dplyr::mutate(h=factor(h,levels=lvls));
ks=c(10,8);
k1 = ks[1]; k2 = ks[2];
frmla  = obsR~ti(z,bs="ts",k=k1) + ti(t,bs="ts",k=k2) + ti(f,bs="ts",k=k2) +
s(s,h,bs="fs",k=k2);
mdl_bestRE = mgcv::gam(frmla,family=famTW,data=dfrDatpp,select=TRUE,method="REML");
wtsUtilities::saveObj(mdl_bestRE, file.path(dirThs,"rda_Step3b.TweedieModels_BestModelRE.RData"));
getModelPlots(mdl_bestRE);
source(file.path(dirThs,"../r_PlotStats_BestModels.R"));
getModelPlots(mdl_bestRE);
source(file.path(dirThs,"../r_SelectModelByConcurvityFunctions.R"));
getModelPlots(mdl_bestRE);
View(lst)
prdMod<-function(mdl,trms,lst,type="response",keep=NULL,p=0.05){
dfr = wtsMGCV::createGridTbl(lst);
if (any(trms=="all")){
#--add intercept and all smooth terms
trmsp = "(Intercept)";
trms = wtsMGCV::getSmoothTerms(mdl);
for (trm in trms) trmsp = c(trmsp,trm);
trms = trmsp;
}
prd = dplyr::bind_cols(
dfr,
tibble::as_tibble(
mgcv::predict.gam(mdl,dfr,type=type,terms=trms,se.fit=TRUE),
) |>
dplyr::mutate(type="fit",
lci=qnorm(p,fit,se.fit,lower.tail=TRUE),
uci=qnorm(p,fit,se.fit,lower.tail=FALSE),
terms=paste(trms,collapse=" + "))
) |>
dplyr::rename(emp_sel=fit);
if (!is.null(keep)){
prd = prd |>
dplyr::distinct(pick(tidyselect::any_of(keep),emp_sel,se.fit,lci,uci,terms));
drop = names(lst)[!(names(lst) %in% keep)];
for (drp in drop) prd[[drp]] = NA;
}
return(prd);
}
plotMod<-function(tmp,ylims=c(0,1.5)){
if (all(is.na(tmp$y))) tmp$y = "all";
p = ggplot(tmp,aes(x=z,y=emp_sel,ymin=lci,ymax=uci,colour=y,fill=y));
if ("n" %in% names(tmp)){
p = p + geom_point(aes(size=n)) + scale_size_area() +
geom_line();
}
p = p +
geom_ribbon(alpha=0.3) +
geom_line() +
geom_hline(yintercept=0.5,linetype=3) +
scale_y_continuous(limits=ylims,oob=scales::squish) +
labs(x="size (mm CW)",y="empirical\nselectivity",
colour="study\nyear",fill="study\nyear",size="crab\nsampled") +
theme(legend.position="inside",
legend.position.inside=c(0.01,0.99),
legend.justification.inside=c(0,1),
legend.byrow=TRUE,
legend.box="horizontal");
return(p);
}
dfrPrd = prdMod(mdl_bestRE,trms=c("all"),lst=lst$grids,type="response");
lst1=list(lst$grids,h=factor("any"))
View(lst1)
lst1=c(lst$grids,h=factor("any"))
h=factor("any")
dirThs = dirname(rstudioapi::getActiveDocumentContext()$path);
#--get trimmed data----
lst = wtsUtilities::getObj(file.path(dirThs,"../rda_Step2_TrimmedDataList.RData"));
dfrDat =  lst$lstTrimmedFinal$dfrDat |>
dplyr::mutate(obsR=exp(lnR),
nN=round(p*n), #--number caught in NMFS gear
nB=n-nN);      #--number caught in BSFRF gear
#--extract characteristics from size and environmental data----
##--size----
grd_z = seq(5,180,5)+2.5; med_z = 100.0; #--for males
##--depth----
med_d = median(dfrDat$d,na.rm=TRUE); rng_d = range(dfrDat$d,na.rm=TRUE);
grd_d = seq(from=rng_d[1],rng_d[2],length.out=50);
##--temperature----
med_t = median(dfrDat$t,na.rm=TRUE); rng_t = range(dfrDat$t,na.rm=TRUE);
grd_t = seq(from=rng_t[1],rng_t[2],length.out=50);
##--phi----
med_f = median(dfrDat$f,na.rm=TRUE); rng_f = range(dfrDat$f,na.rm=TRUE);
grd_f = seq(from=rng_f[1],rng_f[2],length.out=50);
##--sorting----
med_s = median(dfrDat$s,na.rm=TRUE); rng_s = range(dfrDat$s,na.rm=TRUE);
grd_s = seq(from=rng_s[1],rng_s[2],length.out=50);
meds  = list(z=med_z,d=med_d,t=med_t,f=med_f,s=med_s);
grids = list(z=grd_z,d=grd_d,t=grd_t,f=grd_f,s=grd_s);
lbls  = list(z="size (mm CW)",d="depth (m)",t="temperature (deg C)",f="-log2(phi)",s="sorting coeff.")
#--the logit-scale observed proportions "o=nN/(nN+nB)" are related to the
#--NMFS-to-BSFRF selectivity ratio "r" (S_nmfs/S_bsfrf) by
#     logit(o) = ln(r) + ln(q)
# where q = expF_b/expF_n is the ratio of expansion factors used to convert
# numbers sampled to CPUE: i.e., CPUE = N_s * expF, where expF = 1/(As * Sf),
# and As = area swept and Sf is the sampling fraction (note that
# the SAMPLING_FACTOR in the haul data tables is 1/(sampling fraction),
# so expF = SAMPLING_FACTOR/AREA_SWEPT).
#--set sex
x = "MALE";
dfrDat   = dfrDat |> dplyr::filter(x=="MALE") |> dplyr::mutate(obsR=exp(lnR));
lst = list(x=x,dfrDat=dfrDat,meds=meds,grids=grids,lbls=lbls);
wtsUtilities::saveObj(lst,file.path(dirThs,"rda_Step3a.CensoredDataAndGridsList.Males.RData"));
grdPrd = list(z=lst$grids$z,d=lst$meds$d,t=lst$meds$t,f=lst$meds$f,s=lst$meds$s,h=factor("any"))
dfrPrd = prdMod(mdl_bestRE,trms=c("all"),type="response",
lst=grdPrd);
View(dfrPrd)
str(dfrPrd)
str(dfrDatp)
mdl_bestRE
summary(mdl_bestRE)
str(dfrDatpp)
lst=grdPrd
dfr = wtsMGCV::createGridTbl(lst);
View(dfr)
#--add intercept and all smooth terms
trmsp = "(Intercept)";
trms = wtsMGCV::getSmoothTerms(mdl);
mdl = mdl_bestRE
#--add intercept and all smooth terms
trmsp = "(Intercept)";
trms = wtsMGCV::getSmoothTerms(mdl);
for (trm in trms) trmsp = c(trmsp,trm);
trms = trmsp;
}
#--add intercept and all smooth terms
trmsp = "(Intercept)";
trms = wtsMGCV::getSmoothTerms(mdl);
for (trm in trms) trmsp = c(trmsp,trm);
trms = trmsp;
trms
type="response"
mgcv::predict.gam(mdl,dfr,type=type,terms=trms,se.fit=TRUE),
mgcv::predict.gam(mdl,dfr,type=type,terms=trms,se.fit=TRUE)
View(mdl_bestRE)
str(mdl_bestRE$model)
str(dfrDatpp)
grdPrd = list(z=lst$grids$z,d=lst$meds$d,t=lst$meds$t,f=lst$meds$f,s=lst$meds$s,h=factor("2013-2"))
dfrPrd = prdMod(mdl_bestRE,trms=c("all"),type="response",lst=grdPrd);
lst$meds$f
lst$meds
lst = wtsUtilities::getObj(file.path(dirThs,"rda_Step3a.CensoredDataAndGridsList.Males.RData"));
grdPrd = list(z=lst$grids$z,d=lst$meds$d,t=lst$meds$t,f=lst$meds$f,s=lst$meds$s,h=factor("2013-2"))
grdPrd
dfrPrd = prdMod(mdl_bestRE,trms=c("all"),type="response",lst=grdPrd);
View(dfrPrd)
require(DHARMa);
require(dplyr);
require(ggplot2);
require(gratia)
require(mgcv);
#--get censored data and prediction grids----
dirThs = dirname(rstudioapi::getActiveDocumentContext()$path);
lst = wtsUtilities::getObj(file.path(dirThs,"rda_Step3a.CensoredDataAndGridsList.Males.RData"));
#--remove zeros, infs, questionable observed Rs----
dfrDatp   = lst$dfrDat |> dplyr::filter(obsR<10, is.finite(lnR),between(z,15,150));
#--TWEEDIE regression models for lnR---------------------
famTW = mgcv::tw(link="log");
ks=c(10,8);
k1 = ks[1]; k2 = ks[2];
lvls = c("any",unique(dfrDatp$h));
dfrDatpp = dfrDatp |> dplyr::mutate(h=factor(h,levels=lvls));
str(dfrDatpp)
ks=c(10,8);
k1 = ks[1]; k2 = ks[2];
frmla  = obsR~ti(z,bs="ts",k=k1) + ti(t,bs="ts",k=k2) + ti(f,bs="ts",k=k2) +
s(s,h,bs="fs",k=k2);
mdl_bestRE = mgcv::gam(frmla,family=famTW,data=dfrDatpp,select=TRUE,method="REML");
str(mdl_bestRE$model)
#----function to predict values based on a model
prdMod<-function(mdl,trms,lst,type="response",keep=NULL,p=0.05){
dfr = wtsMGCV::createGridTbl(lst);
if (any(trms=="all")){
#--add intercept and all smooth terms
trmsp = "(Intercept)";
trms = wtsMGCV::getSmoothTerms(mdl);
for (trm in trms) trmsp = c(trmsp,trm);
trms = trmsp;
}
prd = dplyr::bind_cols(
dfr,
tibble::as_tibble(
mgcv::predict.gam(mdl,dfr,type=type,terms=trms,se.fit=TRUE),
) |>
dplyr::mutate(type="fit",
lci=qnorm(p,fit,se.fit,lower.tail=TRUE),
uci=qnorm(p,fit,se.fit,lower.tail=FALSE),
terms=paste(trms,collapse=" + "))
) |>
dplyr::rename(emp_sel=fit);
if (!is.null(keep)){
prd = prd |>
dplyr::distinct(pick(tidyselect::any_of(keep),emp_sel,se.fit,lci,uci,terms));
drop = names(lst)[!(names(lst) %in% keep)];
for (drp in drop) prd[[drp]] = NA;
}
return(prd);
}
grdPrd = list(z=lst$grids$z,d=lst$meds$d,t=lst$meds$t,f=lst$meds$f,s=lst$meds$s,h=factor("any"))
dfrPrd = prdMod(mdl_bestRE,trms=c("all"),type="response",lst=grdPrd);
View(dfrPrd)
mdl_bestRE = mgcv::gam(frmla,family=famTW,data=dfrDatpp,select=TRUE,method="REML",
drop.unused.levels=FALSE);#--use for RE with "any" factor level
wtsUtilities::saveObj(mdl_bestRE, file.path(dirThs,"rda_Step3b.TweedieModels_BestModelRE.RData"));
dfrPrd = prdMod(mdl_bestRE,trms=c("all"),type="response",lst=grdPrd);
plotMod(dfrPrd)
plotMod<-function(tmp,ylims=c(0,1.5)){
if (all(is.na(tmp$y))) tmp$y = "all";
p = ggplot(tmp,aes(x=z,y=emp_sel,ymin=lci,ymax=uci,colour=y,fill=y));
if ("n" %in% names(tmp)){
p = p + geom_point(aes(size=n)) + scale_size_area() +
geom_line();
}
p = p +
geom_ribbon(alpha=0.3) +
geom_line() +
geom_hline(yintercept=0.5,linetype=3) +
scale_y_continuous(limits=ylims,oob=scales::squish) +
labs(x="size (mm CW)",y="empirical\nselectivity",
colour="study\nyear",fill="study\nyear",size="crab\nsampled") +
theme(legend.position="inside",
legend.position.inside=c(0.01,0.99),
legend.justification.inside=c(0,1),
legend.byrow=TRUE,
legend.box="horizontal");
return(p);
}
plotMod(dfrPrd)
#--fit various models for ln(r) using mgcv to fit GAMs for males using the BINOMIAL distribution----
require(DHARMa);
require(dplyr);
require(ggplot2);
require(gratia)
require(mgcv);
#--get censored data and prediction grids----
dirThs = dirname(rstudioapi::getActiveDocumentContext()$path);
lst = wtsUtilities::getObj(file.path(dirThs,"rda_Step3a.CensoredDataAndGridsList.Males.RData"));
#--remove zeros, infs, questionable observed Rs----
#dfrDatp   = lst$dfrDat |> dplyr::filter(obsR<10, is.finite(lnR),between(z,15,150));
dfrDatp   = lst$dfrDat |> dplyr::filter(between(z,15,150));
#--BINOMIAL regression  models for lnR----
famB = stats::binomial(link="logit");
source(file.path(dirThs,"../r_gam.prefit.functions.R"));
source(file.path(dirThs,"../r_SelectModelByConcurvityFunctions.R"));
source(file.path(dirThs,"../r_PlotStats_BestModels.R"));
mdl = mdlB_ZE2D;
ks=c(20,10);
k1 = ks[1]; k2 = ks[2];
frmla  = p~ti(z,bs="ts",k=k1)   +
ti(d,bs="ts",k=k2)   + ti(t,bs="ts",k=k2)   + ti(f,bs="ts",k=k2)   + ti(s,bs="ts",k=k2) +
ti(z,d,bs="ts",k=c(k1,k2)) + ti(z,t,bs="ts",k=c(k1,k2)) + ti(z,f,bs="ts",k=c(k1,k2)) + ti(z,s,bs="ts",k=c(k1,k2));
mdlB_ZE2D  = mgcv::gam(frmla,family=famB,data=dfrDatp,select=TRUE,method="REML",fit=FALSE,
offset=lnq,weights=n);
mdl = mdlB_ZE2D;
if (!exists("dfrCrsVal")) dfrCrsVal = wtsUtilities::getObj(file.path(dirThs,"rda_BinomialModels_CrsVal.RData"));
if (!exists("dfrCrsVal")) dfrCrsVal = wtsUtilities::getObj(file.path(dirThs,"rda_Step3b.BinomialModels_CrsVal.RData"));
dfrCrsVal1 = dfrCrsVal |>
dplyr::filter(i==1) |> #--extract base model results
dplyr::select(fold,
base_rsqr=rsqr,base_aic=aic,base_rsqr_prd=rsqr_prd,
base_mspe_prd=mspe_prd,base_mase_prd=mase_prd);
#--calculate stats differences by fold relative to the base model stats
dfrCrsVald = dfrCrsVal |>
dplyr::left_join(dfrCrsVal1,by=c("fold")) |>
dplyr::mutate(impr_rsqr=rsqr-base_rsqr,
impr_aic=base_aic-aic,
impr_rsqr_prd=rsqr_prd-base_rsqr_prd,
impr_mspe_prd=(base_mspe_prd-mspe_prd)/base_mspe_prd,
impr_mase_prd=(base_mase_prd-mase_prd)/base_mase_prd);
#--summarize stats differences (mean, median) over folds
dfrCrsValdp = dfrCrsVald |>
dplyr::group_by(i,frmla,smths) |>
dplyr::summarize(scrSignifp=sum(as.numeric(signifp)),
scrSignifs=sum(as.numeric(signifs)),
scrConcrv_tst=sum(as.numeric(concrv_tst)),
mn_impr_rsqr=mean(impr_rsqr),
mn_impr_aic=mean(impr_aic),
mn_impr_rsqr_prd=mean(impr_rsqr_prd),
mn_impr_mspe_prd=mean(impr_mspe_prd),
mn_impr_mase_prd=mean(impr_mase_prd),
md_impr_rsqr=median(impr_rsqr),
md_impr_aic=median(impr_aic),
md_impr_rsqr_prd=median(impr_rsqr_prd),
md_impr_mspe_prd=median(impr_mspe_prd),
md_impr_mase_prd=median(impr_mase_prd)
) |>
dplyr::ungroup() |>
dplyr::arrange(i);
#--find best model based on concurvity, significant smooths, and mn_impr_mspe_prd
#----by arranging all models
dfrCrsValdp1 = dfrCrsValdp |>
dplyr::arrange(desc(scrConcrv_tst),
desc(scrSignifs),
desc(mn_impr_mspe_prd));
View(dfrCrsValdp1)
names(dfrCrsValdp1)
#--plot stats from models with better summary stats than the base model
plotStats_BestModels(dfrCrsVald,dfrCrsValdp1);
dfr=dfrCrsVald
dfrd=dfrCrsValdp1
types=c("impr_mspe_prd",
"impr_aic")
fcn<-function(x){
xp = x |>
stringr::str_replace("impr_","") |>
stringr::str_replace("_prd","");
return(xp);
}
typesp = toupper(types |> fcn());
idx  = which(dfrd$i==1);
dfrd = dfrd |> dplyr::slice_head(n=idx);
View(dfrd)
View(dfrCrsVal)
names(dfrCrsVal)
mdl
summary(mdl)
